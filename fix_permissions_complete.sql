-- 1. Cria a tabela se não existir
CREATE TABLE IF NOT EXISTS public.user_permissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  can_access_dashboard boolean DEFAULT false,
  can_access_whatsapp boolean DEFAULT false,
  can_access_ai_agents boolean DEFAULT false,
  can_access_colaboradores boolean DEFAULT false,
  can_access_configuracoes boolean DEFAULT false,
  can_access_administracao boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  CONSTRAINT user_permissions_user_id_key UNIQUE (user_id)
);

-- 2. Remove todas as políticas existentes
DO $$
DECLARE
  policy_record RECORD;
BEGIN
  FOR policy_record IN 
    SELECT polname, relname 
    FROM pg_policies 
    WHERE tablename = 'user_permissions'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON public.user_permissions', policy_record.polname);
  END LOOP;
END $$;

-- 3. Habilita RLS na tabela
ALTER TABLE public.user_permissions ENABLE ROW LEVEL SECURITY;

-- 4. Cria políticas RLS simplificadas para teste
-- Permite que todos os usuários autenticados vejam e modifiquem todas as permissões
CREATE POLICY "Permitir tudo para usuários autenticados" 
ON public.user_permissions
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

-- 5. Concede permissões para os papéis apropriados
GRANT ALL ON TABLE public.user_permissions TO authenticated, service_role;
GRANT ALL ON SEQUENCE public.user_permissions_id_seq TO authenticated, service_role;

-- 6. Cria uma função para inserir/atualizar permissões
CREATE OR REPLACE FUNCTION public.upsert_user_permissions(
  p_user_id uuid,
  p_permissions jsonb
) 
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Verifica se o usuário está autenticado
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Usuário não autenticado';
  END IF;

  -- Verifica se é admin ou o próprio usuário
  IF auth.uid() != p_user_id AND NOT EXISTS (
    SELECT 1 FROM auth.users 
    WHERE id = auth.uid() 
    AND raw_user_meta_data->>'role' = 'admin'
  ) THEN
    RAISE EXCEPTION 'Sem permissão para atualizar estas permissões';
  END IF;

  -- Faz o upsert das permissões
  INSERT INTO public.user_permissions (
    user_id,
    can_access_dashboard,
    can_access_whatsapp,
    can_access_ai_agents,
    can_access_colaboradores,
    can_access_configuracoes,
    can_access_administracao,
    updated_at
  )
  VALUES (
    p_user_id,
    COALESCE((p_permissions->>'can_access_dashboard')::boolean, false),
    COALESCE((p_permissions->>'can_access_whatsapp')::boolean, false),
    COALESCE((p_permissions->>'can_access_ai_agents')::boolean, false),
    COALESCE((p_permissions->>'can_access_colaboradores')::boolean, false),
    COALESCE((p_permissions->>'can_access_configuracoes')::boolean, false),
    COALESCE((p_permissions->>'can_access_administracao')::boolean, false),
    now()
  )
  ON CONFLICT (user_id) 
  DO UPDATE SET
    can_access_dashboard = EXCLUDED.can_access_dashboard,
    can_access_whatsapp = EXCLUDED.can_access_whatsapp,
    can_access_ai_agents = EXCLUDED.can_access_ai_agents,
    can_access_colaboradores = EXCLUDED.can_access_colaboradores,
    can_access_configuracoes = EXCLUDED.can_access_configuracoes,
    can_access_administracao = EXCLUDED.can_access_administracao,
    updated_at = now()
  RETURNING to_jsonb(public.user_permissions.*);

  RETURN jsonb_build_object('status', 'success', 'message', 'Permissões atualizadas com sucesso');
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'status', 'error',
    'message', SQLERRM,
    'code', SQLSTATE
  );
END;
$$;

-- 7. Cria uma função para buscar permissões
CREATE OR REPLACE FUNCTION public.get_user_permissions(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_result jsonb;
BEGIN
  -- Verifica se o usuário está autenticado
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Usuário não autenticado';
  END IF;

  -- Verifica se é admin ou o próprio usuário
  IF auth.uid() != p_user_id AND NOT EXISTS (
    SELECT 1 FROM auth.users 
    WHERE id = auth.uid() 
    AND raw_user_meta_data->>'role' = 'admin'
  ) THEN
    RAISE EXCEPTION 'Sem permissão para visualizar estas permissões';
  END IF;

  -- Busca as permissões do usuário
  SELECT to_jsonb(up.*) INTO v_result
  FROM public.user_permissions up
  WHERE up.user_id = p_user_id;

  -- Se não encontrar, retorna um objeto vazio
  IF v_result IS NULL THEN
    RETURN jsonb_build_object(
      'user_id', p_user_id,
      'can_access_dashboard', false,
      'can_access_whatsapp', false,
      'can_access_ai_agents', false,
      'can_access_colaboradores', false,
      'can_access_configuracoes', false,
      'can_access_administracao', false
    );
  END IF;

  RETURN v_result;
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object(
    'status', 'error',
    'message', SQLERRM,
    'code', SQLSTATE
  );
END;
$$;

-- 8. Concede permissão para executar as funções
GRANT EXECUTE ON FUNCTION public.upsert_user_permissions(uuid, jsonb) TO authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_user_permissions(uuid) TO authenticated, service_role;

-- 9. Cria um gatilho para atualizar o updated_at
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 10. Aplica o gatilho à tabela
DROP TRIGGER IF EXISTS update_user_permissions_updated_at ON public.user_permissions;
CREATE TRIGGER update_user_permissions_updated_at
BEFORE UPDATE ON public.user_permissions
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- 11. Verifica se as políticas foram aplicadas corretamente
SELECT * FROM pg_policies WHERE tablename = 'user_permissions';

-- 12. Verifica as permissões da tabela
SELECT grantee, privilege_type 
FROM information_schema.role_table_grants 
WHERE table_name = 'user_permissions';
