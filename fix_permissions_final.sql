-- 1. Garante que a tabela existe e tem a estrutura correta
CREATE TABLE IF NOT EXISTS public.user_permissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  can_access_dashboard boolean DEFAULT false,
  can_access_whatsapp boolean DEFAULT false,
  can_access_ai_agents boolean DEFAULT false,
  can_access_colaboradores boolean DEFAULT false,
  can_access_configuracoes boolean DEFAULT false,
  can_access_administracao boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  CONSTRAINT user_permissions_user_id_key UNIQUE (user_id)
);

-- 2. Cria a função para atualizar o updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Cria o trigger para atualizar o updated_at
DROP TRIGGER IF EXISTS on_user_permissions_updated ON public.user_permissions;
CREATE TRIGGER on_user_permissions_updated
  BEFORE UPDATE ON public.user_permissions
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

-- 4. Habilita RLS na tabela
ALTER TABLE public.user_permissions ENABLE ROW LEVEL SECURITY;

-- 5. Remove políticas antigas se existirem
DROP POLICY IF EXISTS "users_read_own_permissions" ON public.user_permissions;
DROP POLICY IF EXISTS "admins_full_access" ON public.user_permissions;
DROP POLICY IF EXISTS "users_update_own_permissions" ON public.user_permissions;
DROP POLICY IF EXISTS "users_insert_own_permissions" ON public.user_permissions;

-- 6. Cria as novas políticas RLS
-- Permite que usuários vejam suas próprias permissões
CREATE POLICY "users_read_own_permissions" 
ON public.user_permissions
FOR SELECT 
USING (auth.uid() = user_id);

-- Permite que administradores vejam todas as permissões
CREATE POLICY "admins_full_access" 
ON public.user_permissions
FOR ALL
USING (
  EXISTS (
    SELECT 1 
    FROM auth.users 
    WHERE id = auth.uid() 
    AND (raw_user_meta_data->>'role' = 'admin' OR auth.jwt() ->> 'role' = 'service_role')
  )
);

-- Permite que usuários atualizem suas próprias permissões
CREATE POLICY "users_update_own_permissions"
ON public.user_permissions
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Permite que usuários criem suas próprias permissões
CREATE POLICY "users_insert_own_permissions"
ON public.user_permissions
FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- 7. Concede permissões para os papéis apropriados
GRANT ALL ON TABLE public.user_permissions TO authenticated, service_role;
GRANT ALL ON SEQUENCE public.user_permissions_id_seq TO authenticated, service_role;

-- 8. Cria uma função para inserir/atualizar permissões
CREATE OR REPLACE FUNCTION public.upsert_user_permissions(
  p_user_id uuid,
  p_permissions jsonb
) 
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result jsonb;
  is_admin boolean;
BEGIN
  -- Verifica se o usuário é administrador
  SELECT EXISTS (
    SELECT 1 
    FROM auth.users 
    WHERE id = auth.uid() 
    AND (raw_user_meta_data->>'role' = 'admin' OR auth.jwt() ->> 'role' = 'service_role')
  ) INTO is_admin;
  
  -- Se não for admin, verifica se está tentando atualizar as próprias permissões
  IF NOT is_admin AND auth.uid() <> p_user_id THEN
    RAISE EXCEPTION 'Apenas administradores podem atualizar permissões de outros usuários';
  END IF;
  
  -- Faz o upsert das permissões
  INSERT INTO public.user_permissions (
    user_id,
    can_access_dashboard,
    can_access_whatsapp,
    can_access_ai_agents,
    can_access_colaboradores,
    can_access_configuracoes,
    can_access_administracao
  )
  VALUES (
    p_user_id,
    COALESCE(p_permissions->>'can_access_dashboard', 'false')::boolean,
    COALESCE(p_permissions->>'can_access_whatsapp', 'false')::boolean,
    COALESCE(p_permissions->>'can_access_ai_agents', 'false')::boolean,
    COALESCE(p_permissions->>'can_access_colaboradores', 'false')::boolean,
    COALESCE(p_permissions->>'can_access_configuracoes', 'false')::boolean,
    COALESCE(p_permissions->>'can_access_administracao', 'false')::boolean
  )
  ON CONFLICT (user_id) 
  DO UPDATE SET
    can_access_dashboard = EXCLUDED.can_access_dashboard,
    can_access_whatsapp = EXCLUDED.can_access_whatsapp,
    can_access_ai_agents = EXCLUDED.can_access_ai_agents,
    can_access_colaboradores = EXCLUDED.can_access_colaboradores,
    can_access_configuracoes = EXCLUDED.can_access_configuracoes,
    can_access_administracao = EXCLUDED.can_access_administracao
  RETURNING to_jsonb(public.user_permissions.*) INTO result;
  
  RETURN jsonb_build_object('success', true, 'data', result);
EXCEPTION
  WHEN others THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM,
      'state', SQLSTATE
    );
END;
$$;

-- 9. Concede permissão para executar a função
GRANT EXECUTE ON FUNCTION public.upsert_user_permissions(uuid, jsonb) TO authenticated, service_role;

-- 10. Cria uma função para obter permissões de forma segura
CREATE OR REPLACE FUNCTION public.get_user_permissions(p_user_id uuid)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result jsonb;
  is_admin boolean;
  is_own_record boolean;
BEGIN
  -- Verifica se é administrador
  SELECT EXISTS (
    SELECT 1 
    FROM auth.users 
    WHERE id = auth.uid() 
    AND (raw_user_meta_data->>'role' = 'admin' OR auth.jwt() ->> 'role' = 'service_role')
  ) INTO is_admin;
  
  -- Verifica se está acessando o próprio registro
  is_own_record := (auth.uid() = p_user_id);
  
  -- Apenas administradores podem ver permissões de outros usuários
  IF NOT is_admin AND NOT is_own_record THEN
    RAISE EXCEPTION 'Apenas administradores podem ver permissões de outros usuários';
  END IF;
  
  -- Busca as permissões
  SELECT to_jsonb(up.*) INTO result
  FROM public.user_permissions up
  WHERE up.user_id = p_user_id;
  
  RETURN jsonb_build_object('success', true, 'data', COALESCE(result, 'null'::jsonb));
EXCEPTION
  WHEN others THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM,
      'state', SQLSTATE
    );
END;
$$;

-- 11. Concede permissão para executar a função
GRANT EXECUTE ON FUNCTION public.get_user_permissions(uuid) TO authenticated, service_role;
